defmodule Beeleex.Api do
  @moduledoc """
  This is in charge of interfacing with the Beelee GraphQL server
  To update data like Business Units, the Billing Center, companies or generate/update invoices
  """
  require Logger

  defp url do
    Application.get_env(:beeleex, :beelee_endpoint, "https://beelee.geeks.solutions/v0-1/api")
  end

  defp headers do
    [
      {"content-type", "application/json"},
      {"secure-key", Application.get_env(:beeleex, :business_unit_secure_key)},
      {"bu-id", Application.get_env(:beeleex, :business_unit_id)}
    ]
  end

  @doc """
  This function will update invoices that were freshly generated by Beelee when a new cycle started
  """
  @spec update_invoices(list(Beeleex.InvoiceUpdate.t())) ::
          {:ok, String.t()} | {:error, String.t()}
  def update_invoices(invoices) when is_list(invoices) do
    company_invoices = Enum.map(invoices, &Beeleex.InvoiceUpdate.format_payload(&1))

    case ExGeeks.Helpers.endpoint_post_callback(
           url(),
           %{
             query: """
             mutation updateCompanyInvoices($companyInvoices: [InvoiceInput]) {
               updateCompanyInvoices(companyInvoices: $companyInvoices) {
                 message
               }
             }
             """,
             variables: %{
               companyInvoices: company_invoices
             }
           },
           headers()
         ) do
      %{"data" => %{"updateCompanyInvoices" => %{"message" => message}}} ->
        {:ok, message}

      %{"data" => _, "errors" => errors} ->
        error = List.first(errors)["message"]
        Logger.error("#{__ENV__.function |> elem(0)}: #{error}")
        {:error, error}
    end
  end

  @doc """
  This function returns the company that is linked to your customer_project ID.
  It is helpful to update the company data related to a project in your Business Unit
  """
  @spec get_company_by_customer_project(String.t()) ::
          {:ok, Beeleex.Company.t()} | {:error, String.t()}
  def get_company_by_customer_project(customer_project) do
    case ExGeeks.Helpers.endpoint_post_callback(
           url(),
           %{
             query: """
             query getcompany($customer_project:String!){
               getCompanyByCustomerProject(customerProject:$customer_project) {
                   address{
                     city
                     country
                     postalCode
                     streetName
                   }
                   name
                   email
                   phoneNumber
                   customerProjects
                   vatNumber
                   businessUnit{
                     id
                     archived
                     name
                     billingCenter{
                       name
                       id
                       vatNumber
                     }
                     cycle
                     job{
                       scheduledAt
                     }
                   }
                   userId
                   id
                   solvencyStatus
                 }}
             """,
             variables: %{
               customer_project: customer_project
             }
           },
           headers()
         ) do
      %{"data" => %{"getCompanyByCustomerProject" => company}} ->
        company
        |> ExGeeks.Helpers.atomize_keys(transformer: &Macro.underscore/1)
        |> Beeleex.Company.compute_bu_cycle()
        |> then(fn company -> {:ok, struct(Beeleex.Company, company)} end)

      %{"data" => _, "errors" => errors} ->
        error = List.first(errors)["message"]
        Logger.error("#{__ENV__.function |> elem(0)}: #{error}")
        {:error, error}
    end
  end

  @doc """
  This function will create a new one time payment invoice on Beelee and immediately initiate a payment collection for this invoice
  """
  @spec generate_onetime_invoice(Beeleex.OnetimePayment.t()) ::
          {:ok, String.t()} | {:error, String.t()}
  def generate_onetime_invoice(onetime_payment) do
    case ExGeeks.Helpers.endpoint_post_callback(
           url(),
           %{
             query: """
             mutation generateInvoice($onetimeInvoice: OnetimeInvoiceInput) {
              generateOnetimeInvoice(companyInvoice: $onetimeInvoice) {
                id
                amount_before_tax
                tax_amount
                tax_rate
                amount_with_tax
                status
                type
                reduction_amount_before_tax
                reduction_tax_amount
                reduction_amount_with_tax
              }
             }
             """,
             variables: %{
               onetimeInvoice: onetime_payment
             }
           },
           headers()
         ) do
      %{"data" => %{"generateOnetimeInvoice" => invoice}} ->
        invoice
        |> ExGeeks.Helpers.atomize_keys(transformer: &Macro.underscore/1)
        |> then(fn company -> {:ok, struct(Beeleex.Invoice, company)} end)

      %{"data" => _, "errors" => errors} ->
        error = List.first(errors)["message"]
        Logger.error("#{__ENV__.function |> elem(0)}: #{error}")
        {:error, error}
    end
  end

  @doc """
  Loads the last invoice for the provided project ID for a given package in the current cycle
  """
  @spec get_current_cycle_invoice(String.t(), String.t()) ::
          {:ok, Beeleex.Invoice.t()} | {:error, String.t()}
  def get_current_cycle_invoice(project_id, package_name) do
    case ExGeeks.Helpers.endpoint_post_callback(
           url(),
           %{
             query: """
             query getInvoices($filter: [Filter], $size: Int, $skip: Int) {
               getInvoices(filter: $filter, size: $size, skip: $skip) {
                 invoices {
                   id
                   amount_before_tax
                   tax_amount
                   tax_rate
                   amount_with_tax
                   cycle
                   beginning
                   end
                   type
                   reduction_amount_before_tax
                   reduction_tax_amount
                   reduction_amount_with_tax
                   status
                   breakdown {
                     projectId
                     packageName
                   }
                 }
                 count
                 total
               }
             }
             """,
             variables: %{
               filter: [
                 %{key: "project_id", value: project_id},
                 %{key: "package_name", value: package_name}
               ],
               size: 1,
               current_cycle: true
             }
           },
           headers()
         ) do
      %{"data" => %{"getInvoices" => %{"count" => 0}}} ->
        {:error, "no_match"}

      %{"data" => %{"getInvoices" => %{"invoices" => [invoice]}}} ->
        invoice
        |> ExGeeks.Helpers.atomize_keys(transformer: &Macro.underscore/1)
        |> then(fn invoice -> {:ok, struct(Beeleex.Invoice, invoice)} end)

      %{"data" => _, "errors" => errors} ->
        error = List.first(errors)["message"]
        Logger.error("#{__ENV__.function |> elem(0)}: #{error}")
        {:error, error}
    end
  end

  @doc """
  Generate a new credit note, requires:
  - An amount in integer with the same decimal places as the originating invoice
  - The originating invoice id
  - A reason string
  - Optionally you can also provide a list of tags
  """
  @spec generate_credit_note(integer(), integer(), String.t(), list(String.t()) | nil) ::
          {:ok, Beeleex.CreditNote.t()} | {:error, String.t()}
  def generate_credit_note(amount, originating_invoice_id, reason, tags \\ []) do
    case ExGeeks.Helpers.endpoint_post_callback(
           url(),
           %{
             query: """
             mutation createCreditNote($CreditNote: CreditNoteInput!) {
              createCreditNote(CreditNote: $CreditNote) {
                id
                reason
                amount
                tags
                status
                remainingAmount
                originatingInvoice {
                  id
                  status
                }
              }
             }
             """,
             variables: %{
               CreditNote: %{
                 reason: reason,
                 amount: amount,
                 tags: tags,
                 originatingInvoiceId: originating_invoice_id
               }
             }
           },
           headers()
         ) do
      %{"data" => %{"createCreditNote" => %{"id" => _} = credit_note}} ->
        credit_note
        |> ExGeeks.Helpers.atomize_keys(transformer: &Macro.underscore/1)
        |> then(fn credit_note -> {:ok, struct(Beeleex.CreditNote, credit_note)} end)

      %{"data" => _, "errors" => errors} ->
        error = List.first(errors)["message"]
        Logger.error("#{__ENV__.function |> elem(0)}: #{error}")
        {:error, error}
    end
  end
end
